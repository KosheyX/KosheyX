from hikkatl.types import Message, UserStatusOnline, UserStatusOffline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth
from hikkatl.tl.types import PeerUser, PeerChat, PeerChannel
from datetime import datetime, timedelta
import asyncio
from .. import loader, utils

@loader.tds
class UserTrackerMod(loader.Module):
    """–ú–æ–¥—É–ª—å –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    strings = {
        "name": "UserTracker",
        "tracking_started": "üöÄ –ù–∞—á–∞—Ç–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {}",
        "tracking_stopped": "üõë –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {}",
        "no_user": "‚ùå –£–∫–∞–∂–∏—Ç–µ ID –∏–ª–∏ —é–∑–µ—Ä–Ω–µ–π–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è",
        "report": (
            "üìä –û—Ç—á–µ—Ç –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {}\n\n"
            "üü¢ –ë—ã–ª –æ–Ω–ª–∞–π–Ω: {}\n"
            "üî¥ –ë—ã–ª –æ—Ñ—Ñ–ª–∞–π–Ω: {}\n"
            "‚è± –í—Å–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ —Å–µ—Ç–∏: {}\n"
            "üí¨ –ß–∞—Ç—ã –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:\n{}\n"
            "üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞:\n{}"
        ),
        "chat_entry": "  - {} ({} —Å–æ–æ–±—â–µ–Ω–∏–π, –≤—Ä–µ–º—è: {})",
        "status_online": "üü¢ –í —Å–µ—Ç–∏",
        "status_offline": "üî¥ –ù–µ –≤ —Å–µ—Ç–∏",
        "status_recently": "üü° –ë—ã–ª –Ω–µ–¥–∞–≤–Ω–æ",
        "status_last_week": "üü† –ë—ã–ª –Ω–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ",
        "status_last_month": "üîµ –ë—ã–ª –≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ",
        "status_long_ago": "‚ö´ –î–∞–≤–Ω–æ –Ω–µ –±—ã–ª –≤ —Å–µ—Ç–∏",
        "not_tracking": "‚ùå –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –Ω–µ –∑–∞–ø—É—â–µ–Ω–æ",
    }

    def __init__(self):
        self.config = loader.ModuleConfig(
            loader.ConfigValue(
                "report_chat",
                "https://t.me/+ve_fxQ6dYj9hOTJi",
                "–ß–∞—Ç –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç—á–µ—Ç–æ–≤",
                validator=loader.validators.Link()
            ),
            loader.ConfigValue(
                "check_interval",
                300,
                "–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)",
                validator=loader.validators.Integer(minimum=60)
            ),
            loader.ConfigValue(
                "track_messages",
                True,
                "–û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
                validator=loader.validators.Boolean()
            ),
        )
        self.tracked_user = None
        self.tracking = False
        self.user_data = {}
        self.last_check = None
        self.online_times = {}
        self.message_counts = {}
        self._task = None

    async def client_ready(self, client, db):
        self._client = client
        self._db = db

    async def on_unload(self):
        if self._task:
            self._task.cancel()

    async def start_tracking(self):
        if not self.tracked_user:
            return
        
        self.tracking = True
        self.user_data = {
            "first_seen": datetime.now(),
            "last_online": None,
            "last_offline": None,
            "total_online": timedelta(),
            "sessions": [],
            "current_session_start": None,
            "chats": {},
        }
        
        self._task = asyncio.create_task(self._track_loop())

    async def _track_loop(self):
        while self.tracking:
            try:
                await self.check_user_status()
                if self.config["track_messages"]:
                    await self.check_user_chats()
                await self.send_report()
            except Exception as e:
                print(f"[UserTracker] –û—à–∏–±–∫–∞: {e}")
            
            await asyncio.sleep(self.config["check_interval"])

    async def check_user_status(self):
        try:
            user = await self._client.get_entity(self.tracked_user)
            now = datetime.now()
            
            if hasattr(user, 'status'):
                if isinstance(user.status, UserStatusOnline):
                    if not self.user_data["current_session_start"]:
                        self.user_data["current_session_start"] = now
                        self.user_data["last_online"] = now
                        if now.date() not in self.online_times:
                            self.online_times[now.date()] = timedelta()
                elif isinstance(user.status, UserStatusOffline):
                    if self.user_data["current_session_start"]:
                        session_duration = now - self.user_data["current_session_start"]
                        self.user_data["total_online"] += session_duration
                        if now.date() in self.online_times:
                            self.online_times[now.date()] += session_duration
                        else:
                            self.online_times[now.date()] = session_duration
                        self.user_data["sessions"].append({
                            "start": self.user_data["current_session_start"],
                            "end": now,
                            "duration": session_duration
                        })
                        self.user_data["current_session_start"] = None
                        self.user_data["last_offline"] = now
        except Exception as e:
            print(f"[UserTracker] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å—Ç–∞—Ç—É—Å–∞: {e}")

    async def check_user_chats(self):
        try:
            user = await self._client.get_entity(self.tracked_user)
            dialogs = await self._client.get_dialogs()
            
            for dialog in dialogs:
                if dialog.is_user or dialog.is_group or dialog.is_channel:
                    try:
                        chat_id = dialog.id
                        messages = await self._client.get_messages(
                            dialog.entity,
                            from_user=user.id,
                            limit=100,
                            wait_time=2
                        )
                        
                        if chat_id not in self.user_data["chats"]:
                            self.user_data["chats"][chat_id] = {
                                "name": dialog.name,
                                "message_count": 0,
                                "last_message": None,
                                "time_spent": timedelta()
                            }
                        
                        prev_count = self.user_data["chats"][chat_id]["message_count"]
                        self.user_data["chats"][chat_id]["message_count"] = len(messages)
                        
                        if messages:
                            self.user_data["chats"][chat_id]["last_message"] = messages[0].date
                            
                            if len(messages) > prev_count:
                                if chat_id in self.message_counts:
                                    time_diff = messages[0].date - self.message_counts[chat_id]["last_time"]
                                    self.user_data["chats"][chat_id]["time_spent"] += time_diff
                                self.message_counts[chat_id] = {
                                    "count": len(messages),
                                    "last_time": messages[0].date
                                }
                    except Exception as e:
                        print(f"[UserTracker] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —á–∞—Ç–∞ {dialog.name}: {e}")
                        continue
        except Exception as e:
            print(f"[UserTracker] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —á–∞—Ç–æ–≤: {e}")

    async def send_report(self):
        if not self.tracked_user or not self.user_data:
            return
        
        try:
            user = await self._client.get_entity(self.tracked_user)
            chat_list = "\n".join(
                self.strings("chat_entry").format(
                    chat["name"],
                    chat["message_count"],
                    str(chat["time_spent"]).split(".")[0]
                )
                for chat in self.user_data["chats"].values()
            )
            
            today = datetime.now().date()
            yesterday = today - timedelta(days=1)
            today_time = self.online_times.get(today, timedelta())
            yesterday_time = self.online_times.get(yesterday, timedelta())
            
            stats_24h = (
                f"–°–µ–≥–æ–¥–Ω—è: {str(today_time).split('.')[0]}\n"
                f"–í—á–µ—Ä–∞: {str(yesterday_time).split('.')[0]}\n"
                f"–í—Å–µ–≥–æ —Å–µ—Å—Å–∏–π: {len(self.user_data['sessions'])}"
            )
            
            report = self.strings("report").format(
                utils.get_display_name(user),
                self.user_data["last_online"].strftime("%Y-%m-%d %H:%M:%S") if self.user_data["last_online"] else "N/A",
                self.user_data["last_offline"].strftime("%Y-%m-%d %H:%M:%S") if self.user_data["last_offline"] else "N/A",
                str(self.user_data["total_online"]).split(".")[0],
                chat_list if chat_list else "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —á–∞—Ç–∞—Ö",
                stats_24h
            )
            
            await self._client.send_message(self.config["report_chat"], report)
        except Exception as e:
            print(f"[UserTracker] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç—á–µ—Ç–∞: {e}")

    @loader.command()
    async def track(self, message: Message):
        """–ù–∞—á–∞—Ç—å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .track <id/—é–∑–µ—Ä–Ω–µ–π–º>"""
        args = utils.get_args_raw(message)
        if not args:
            await utils.answer(message, self.strings("no_user"))
            return
        
        if self.tracking:
            await utils.answer(message, "–£–∂–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å. –°–Ω–∞—á–∞–ª–∞ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Ç–µ–∫—É—â–µ–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ.")
            return
            
        try:
            self.tracked_user = args
            await self.start_tracking()
            await utils.answer(message, self.strings("tracking_started").format(args))
        except Exception as e:
            await utils.answer(message, f"–û—à–∏–±–∫–∞: {str(e)}")

    @loader.command()
    async def untrack(self, message: Message):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ"""
        if not self.tracking:
            await utils.answer(message, self.strings("not_tracking"))
            return
            
        self.tracking = False
        if self._task:
            self._task.cancel()
            self._task = None
            
        await utils.answer(message, self.strings("tracking_stopped").format(self.tracked_user))
        self.tracked_user = None

    @loader.command()
    async def trackreport(self, message: Message):
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π –æ—Ç—á–µ—Ç"""
        if not self.tracking or not self.tracked_user:
            await utils.answer(message, self.strings("not_tracking"))
            return
            
        try:
            await self.send_report()
            await utils.answer(message, "–û—Ç—á–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ —É–∫–∞–∑–∞–Ω–Ω—ã–π —á–∞—Ç")
        except Exception as e:
            await utils.answer(message, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç—á–µ—Ç–∞: {str(e)}")
